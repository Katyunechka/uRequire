// Generated by CoffeeScript 1.4.0
var Build, Bundle, BundleBuilder, Logger, YADC, l, uRequireConfigMasterDefaults, upath, _, _B, _Bs, _fs,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_fs = require('fs');

_B = require('uberscore');

upath = require('../paths/upath');

Logger = require('../utils/Logger');

l = new Logger('BundleBuilder');

uRequireConfigMasterDefaults = require('../config/uRequireConfigMasterDefaults');

Bundle = require('./Bundle');

Build = require('./Build');

_Bs = require('../utils/uBerscoreShortcuts');

require('butter-require')();

/*
  Load config :
    * check options
    * Load (a) bundle(s) and (a) build(s)
    * Build & watch for changes
*/


BundleBuilder = (function() {
  var _this = this;

  Function.prototype.property = function(p) {
    var d, n, _results;
    _results = [];
    for (n in p) {
      d = p[n];
      _results.push(Object.defineProperty(this.prototype, n, d));
    }
    return _results;
  };

  Function.prototype.staticProperty = function(p) {
    var d, n, _results;
    _results = [];
    for (n in p) {
      d = p[n];
      _results.push(Object.defineProperty(BundleBuilder.prototype, n, d));
    }
    return _results;
  };

  function BundleBuilder() {
    this._constructor.apply(this, arguments);
  }

  BundleBuilder.prototype._constructor = function() {
    var be, cfgFilename, config, configs, varNames, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    configs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.configs = configs;
    this.bundleCfg = {};
    this.buildCfg = {};
    this.buildCfg.done = ((_ref = configs[0]) != null ? _ref.done : void 0) || function() {};
    /*
        Default-copy all configuration from all configs... that are passed.
    */

    for (_i = 0, _len = configs.length; _i < _len; _i++) {
      config = configs[_i];
      if (!(config)) {
        continue;
      }
      this.storeCfgDefaults(config);
      _ref1 = _B.arrayize(config.configFiles);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        cfgFilename = _ref1[_j];
        if (cfgFilename) {
          this.storeCfgDefaults(require(_fs.realpathSync(cfgFilename)));
        }
      }
    }
    /*
        We should now have our 'final' configs, @bundleCfg & @buildCfg
    
        Lets check they are ok & fix formats!
    
        @todo:(7 4 5) make part of the recursive fixation above
        @todo:(3 2 9) Make generic, for all kinds of schematization, transforamtion & validation of config data.
    */

    if (this.buildCfg.debugLevel != null) {
      Logger.prototype.debugLevel = this.buildCfg.debugLevel;
    }
    if (!this.buildCfg.verbose) {
      if (Logger.prototype.debugLevel >= 50) {
        l.warn('Enabling verbose, because debugLevel >= 50');
      } else {
        Logger.prototype.verbose = function() {};
      }
    }
    /*
        Lets check & fix different formats or quit if we have anomalies
    */

    if (be = (_ref2 = this.bundleCfg.dependencies) != null ? _ref2.bundleExports : void 0) {
      this.bundleCfg.dependencies.bundleExports = _Bs.toObjectKeysWithArrayValues(be);
      if (!_.isEmpty(this.bundleCfg.dependencies.bundleExports)) {
        l.debug(20, "@bundleCfg.dependencies.bundleExports' = \n", l.prettify((_ref3 = this.bundleCfg.dependencies) != null ? _ref3.bundleExports : void 0));
      }
    }
    _ref6 = [((_ref4 = this.bundleCfg) != null ? (_ref5 = _ref4.dependencies) != null ? _ref5.variableNames : void 0 : void 0) || {}, uRequireConfigMasterDefaults.bundle.dependencies._knownVariableNames];
    for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
      varNames = _ref6[_k];
      _B.mutate(varNames, _B.arrayize);
    }
    l.debug(30, "user @bundleCfg :\n", l.prettify(this.bundleCfg));
    l.debug(30, "user @buildCfg :\n", l.prettify(this.buildCfg));
    if (this.isCheckAndFixPaths() && this.isCheckAndFixTemplate()) {
      this.storeCfgDefaults(uRequireConfigMasterDefaults);
      l.debug(80, "final @bundleCfg :\n", l.prettify(this.bundleCfg));
      l.debug(80, "final @buildCfg :\n", l.prettify(this.buildCfg));
      this.bundle = new Bundle(this.bundleCfg);
      return this.build = new Build(this.buildCfg);
    } else {
      return this.buildCfg.done(false);
    }
  };

  BundleBuilder.prototype.buildBundle = function() {
    if (!(!this.build || !this.bundle)) {
      return this.bundle.buildChangedModules(this.build);
    } else {
      l.err("buildBundle(): I have !@build or !@bundle - can't build!");
      return this.buildCfg.done(false);
    }
  };

  /*
      Store cfg (without overwritting) in our @bundleCfg
      @todo: 1,1 store _.keys uRequireConfigMasterDefaults.bundle & build
  */


  BundleBuilder.prototype.storeCfgDefaults = function(cfg) {
    this.bundleCfg = _B.deepCloneDefaults(this.bundleCfg, _B.go(cfg, {
      fltr: _.keys(uRequireConfigMasterDefaults.bundle)
    }));
    this.bundleCfg = _B.deepCloneDefaults(this.bundleCfg, cfg.bundle || {});
    this.buildCfg = _B.deepCloneDefaults(this.buildCfg, _B.go(cfg, {
      fltr: _.keys(uRequireConfigMasterDefaults.build)
    }));
    return this.buildCfg = _B.deepCloneDefaults(this.buildCfg, cfg.build || {});
  };

  BundleBuilder.prototype.isCheckAndFixTemplate = function() {
    var _ref;
    if (!this.buildCfg.template) {
      this.buildCfg.template = {
        name: 'UMD'
      };
    }
    if (_.isString(this.buildCfg.template)) {
      this.buildCfg.template = {
        name: this.buildCfg.template
      };
    }
    if (_ref = this.buildCfg.template.name, __indexOf.call(Build.templates, _ref) < 0) {
      l.err("Quitting build, invalid template '" + this.buildCfg.template.name + "' specified.\nUse -h for help");
      return false;
    }
    return true;
  };

  BundleBuilder.prototype.isCheckAndFixPaths = function() {
    var cfgFile, _ref;
    if (!this.bundleCfg.bundlePath) {
      if (cfgFile = (_ref = this.configs[0]) != null ? _ref.configFiles[0] : void 0) {
        l.debug(40, "Assuming bundlePath = '" + (upath.dirname(cfgFile)) + "' from 1st configFile: '" + cfgFile + "'");
        this.bundleCfg.bundlePath = upath.dirname(cfgFile);
        return true;
      } else {
        l.err("Quitting build, no bundlePath specified.\nUse -h for help");
        return false;
      }
    } else {
      if (this.buildCfg.forceOverwriteSources) {
        this.buildCfg.outputPath = this.bundleCfg.bundlePath;
        l.verbose("Forced output to '" + this.buildCfg.outputPath + "'");
        return true;
      } else {
        if (!this.buildCfg.outputPath) {
          l.err("Quitting build, no --outputPath specified.\nUse -f *with caution* to overwrite sources.");
          return false;
        } else {
          if (this.buildCfg.outputPath === this.bundleCfg.bundlePath) {
            l.err("Quitting build, outputPath === bundlePath.\nUse -f *with caution* to overwrite sources (no need to specify --outputPath).");
            return false;
          }
        }
      }
    }
    return true;
  };

  return BundleBuilder;

}).call(this);

module.exports = BundleBuilder;

/* Debug information
*/


if (Logger.prototype.debugLevel > 10 || true) {
  YADC = require('YouAreDaChef').YouAreDaChef;
  YADC(BundleBuilder).before(/_constructor/, function(match, config) {
    return l.debug(1, "Before '" + match + "' with config = ", l.prettify(config));
  });
}
